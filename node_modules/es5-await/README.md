# es5-await

es5-await simplify async programming with async/await futures to Node.js

You need some es-6 futured enabled
  * Promise
  * generators*

#Usage

Load module to Node.js environment^

``` javascript
var es5 = require("es5-await");
```

Wrap You function/block code to async() function

``` javascript
var es5 = require("es5-await");
es5.async(function(){...});
```

Call You asynchronus function inside function/block code with yield* es5.await


``` javascript
es5.async(function* () {
  var data yield* es5.await(promise);
  var datum = yield* es5.await(aPromises)
```

And You may call Node's style callback(error, data){...} functions

``` javascript
es5.async(function* () {
  var data = yield * es5.await(fs.readFile, process.cwd() + "/app/Resources/translations/messages.json");
  var aData = yield * es5.await([fs.readFile, process.cwd() + "/app/Resources/translations/messages.json"] ...);
```

Or mix promises and callback

``` javascript
es5.async(function* () {
  var aData = yield * es5.await(promise, [fs.readFile, ...], promise ...);
```

For Express user asyncroute() helper enabled

``` javascript
router.get('/json-editor/get', es5.asyncroute(function*(req, res, next) {
  var lang = res.locals["lang"];
  var data = yield * es5.await(fs.readFile, process.cwd() + "/app/Resources/translations/messages." + lang + ".new.json");
  res.render("JsonEditor/get.html.twig", {
    json: data
    });
}));
```

It's pretty with CoffeeScript

``` coffeescript
router.get '/json-editor/get', asyncroute (req, res, next) ->
  lang = res.locals.lang
  data = yield from tawait fs.readFile, process.cwd() + "/app/Resources/translations/messages." + lang + ".new.json"
  if (data instanceof Error)
    res.status(500).send(data).end()
    return
  res.render "JsonEditor/get.html.twig", json: data
```

Error handlers with Promise store to target variable. No catch/throw need
